// Top-level build file where you can add configuration options common to all sub-projects/modules.
//apply from: rootProject.getRootDir().getAbsolutePath() + "/utils.gradle" //加载uitls.gradle插件

/**
 * buildScript是用来告诉gradle，我们要用到的plugin在哪里，这样以后才可以使用apply 引用该插件
 * 如果没有buildScript块，您可以使用Gradle开箱即用的所有东西。
 * 如果您还想使用第三方插件，任务类或其他类（在构建脚本中！），则必须在buildScript块中指定相应的依赖关系。
 * 比如使用realm数据库时，我们首先要添加其依赖 classpath "io.realm:realm-gradle-plugin:5.1.0"
 * 并且在project下的build.gradle中加载该插件 apply plugin: 'realm-android'
 */

buildscript {

    repositories {//这是仓库
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'// 这是artifact（工件）， 配置在classpath中，


        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }

    // 注意放在此处不可以，放在这里只会打印一次，导致project.getProjectName()都是GradleDemo
    // 说明buildscript blockscript只会加载一次
    //apply from: rootProject.getRootDir().getAbsolutePath() + "/utils.gradle" //加载uitls.gradle插件
}

allprojects {
    repositories {
        google()
        jcenter()
    }
    // allprojects配置该project和其子project，适用于所有project
    // 在该处加载插件，就不需要在所有的project中都加载一遍了
    apply from: rootProject.getRootDir().getAbsolutePath() + "/utils.gradle" //加载uitls.gradle插件
}

subprojects {
    // subprojects 配置所有子project，不会配置根project，所以会导致此处调用project.getProjectName()报错
    //apply from: rootProject.getRootDir().getAbsolutePath() + "/utils.gradle" //加载uitls.gradle插件
}


task clean(type: Delete) {
    delete rootProject.buildDir
}

// 变量,这些变量并不是成员变量，而是定义再方法中的局部变量
def code = 10

def world = 'world!'

def string = "hello $world"

def multiLines = '''begin
   line 1
           line 2
  end
'''


println string
println multiLines

println '-----------------方法-------------------'
// 方法，调用函数时可以不写(),但是有可能会被看成变量,所以使用时最好带上括号，比如println这样的函数，可以不用带
def testFunction(arg1, arg2){
    println "this is a function, arg1 = " + arg1 + "  arg2 = " + arg2
}

testFunction 1, "hehe"
// 没有返回值类型
def noneReturnTypeFunc(){
    // 使用变量code会报错,但是使用string可以，为什么，因为下面的方法叫getString，string被看成了变量，getString使其方法
    // 所以string = I am a string
    10 + string
}

println noneReturnTypeFunc()

import groovy.transform.Field
@Field field = 'field'//要先导入

def printField(){
    println field//此时field是成员变量，可以访问了
}

printField()

// 有返回值类型，String s 要大写，和java一样
String getString(){
    return "I am a string"
}

println getString()

println '-----------------list-------------------'
// 集合
def list = [2, 'haha', true]
// 变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List 会自动
//往该索引添加元素
assert list[0] == 2
assert list[5] == null
list[5] = 5
println list.size()

list.each {
    println it
}

println '-----------------map-------------------'
def map = ['key1':2,'key2':true,'key3':"haha"]
// 读取
println map.key3
println map['key2']
// 存放
map.key4 = 2.5
map['key5'] = 'hehe'
map.each {
    println it
}

println '-----------------闭包------------------- '
// 闭包
/*def xxx = {paramters -> code} //或者
def xxx = {无参数，纯code} 这种case 不需要->符号*/

def aClosure = {
    param1, param2->//这个箭头很关键。箭头前面是参数定义，箭头后面是代码,参数可以带类型，比如int param1, String param2
        println 'this is a closure param1 = ' + param1 + "  param2 = " + param2
}

aClosure.call(1, 'hello')
aClosure(1, 'hello')

// 找出所有符合closure中条件的元素
// 对于一些closure，不知道参数是什么的，可以使用it.来联想可以使用的参数。
// 比如map的findAll方法中it，就有key和value字段，而List并没有
def result = map.findAll{
    it.key == 'key2' || it.value == 2
}

result.each {
    println it
}

println '-----------------io------------------- '

def targetFile = new File('test')
targetFile.eachLine {
    println it
}

def bytes = targetFile.getBytes()
String fileString = new String(bytes)

def inputStream = targetFile.newInputStream()
// 要关闭
inputStream.close()
//使用闭包操作inputStream，以后在Gradle 里会常看到这种搞法
targetFile.withInputStream {
    is->//不用close。Groovy 会自动替你close
        println is.text
}

def srcFile = new File('SrcFile')
targetFile.withOutputStream {
    os->srcFile.withInputStream {
        is -> os << is //利用OutputStream 的<<操作符重载，完成从inputstream 到OutputStream
    }
}

/**
 * initialization phase初始化阶段就是执行settings.gradle
 * configuration phase阶段解析每个project的build.gradle。其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。
 * execution phase阶段就是执行task任务。你在gradle xxx 中指定什么任务，gradle 就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！
 */

// 在initialization phase阶段之后在configuration phase之前，evaluation之前执行。
// 该方法会调用多次，会在每个project configuration之前都会调用
gradle.beforeProject {
    println 'before project evaluation'
}
// 在configuration phase阶段， evaluation之后，也就是任务有向图确定后执行
gradle.taskGraph.whenReady {
    println 'task graph ready'
}
// execution phase 阶段build完成之后运行
gradle.buildFinished {
    println 'build finished'
}

project.getAllprojects().each {
    println 'project name = ' + it.name
}
// 目前root下的build.gradle只有clean一个task
project.getTasks().each {
    println it
}

//project.properties.each {
//    println it
//}

println 'gradle hash code = ' + gradle.hashCode()
println 'home dir = '+gradle.gradleHomeDir
println 'user home dir = ' + gradle.gradleUserHomeDir

gradle.plugins.each {
    println it
}
// 根目录下的build.gradle和project下的build.gradle一样，都会转化成project对象
println 'project.name = ' + project.getProjectName()//GradleDemo